# Downloaded-At Implementation Plan

## Current System Understanding

### Current File Structure
- **Episode Manifest**: `/episode-manifest/full-episode-manifest.json` 
- **Audio Files**: `audio/{podcastId}/{fileKey}.mp3`
- **Transcripts**: `transcripts/{podcastId}/{fileKey}.srt`
- **Search Entries**: `search-entries/{podcastId}/{fileKey}.json`

### Current File Key Format
- Pattern: `{YYYY-MM-DD}_{sanitized-title}`
- Example: `2024-07-25_Simple-Episode-Title`
- Generated by: `getEpisodeFileKey()` in `packages/ingestion/rss-retrieval-lambda/utils/get-episode-file-key.ts`

### Current Title Sanitization (Inadequate)
```typescript
const sanitizedTitle = episodeTitle
    .normalize('NFC')
    .replace(/[/\\?%*:|"<>.]/g, '-')
    .replace(/\s+/g, '-')
    .substring(0, 50);
```

## Problem Statement

1. **Timing Mismatch**: Audio files downloaded locally vs. Lambda can have different ads
2. **File Tracking**: No way to know WHEN a file was downloaded
3. **Inadequate Sanitization**: Unicode chars, symbols like `+` cause issues
4. **File Consistency**: Need to ensure transcript/search-entry match their audio file

## Proposed Solution

### 1. Enhanced File Key Format
- **New Pattern**: `{YYYY-MM-DD}_{sanitized-title}--{unix-timestamp}`
- **Example**: `2024-07-25_Simple-Episode-Title--1721909640000`
- **Benefits**: Unique per download, chronologically sortable, matches exactly, easy to visually scan

### 2. Improved Title Sanitization
- **Allow Only**: Letters (a-z, A-Z), numbers (0-9), underscores (_)
- **Replace Everything Else**: With underscores
- **Example**: `"Caf√© & Na√Øve + More!"` ‚Üí `"Cafe_Naive_More_"`

### 3. Enhanced Episode Manifest
Add new field to `EpisodeInManifest`:
```typescript
export interface EpisodeInManifest {
    // ... existing fields ...
    downloadedAt?: string; // ISO 8601 timestamp when audio was downloaded
}
```

## Implementation Notes

‚ö†Ô∏è **IMPORTANT**: When updating things in `/packages`, always run `pnpm all:build` before using/testing those utils in other packages to update types, etc. Use `pnpm` throughout the project.

## Implementation Plan

### Phase 1: Core Infrastructure Updates ‚úÖ **COMPLETED**

#### 1.1 Update Type Definitions ‚úÖ
**File**: `packages/types/episode-manifest.ts`
- ‚úÖ Added `downloadedAt?: string` to `EpisodeInManifest` interface

#### 1.2 Enhanced File Key Generation ‚úÖ
**File**: `packages/ingestion/rss-retrieval-lambda/utils/get-episode-file-key.ts`
- ‚úÖ Created new function: `getEpisodeFileKeyWithDownloadedAt(title, pubDate, downloadedAt)`
- ‚úÖ Implemented strict title sanitization (alphanumeric + underscore only)
- ‚úÖ Maintained backwards compatibility function for migration
- ‚úÖ Added utility functions: `hasDownloadedAtTimestamp()`, `extractDownloadedAtFromFileKey()`, `parseFileKey()`
- ‚úÖ Comprehensive test suite (28 tests passing)

**File**: `packages/validation/utils/get-episode-file-key.ts`
- ‚úÖ Duplicated all functions for consistency across packages

#### 1.3 Update Constants Package ‚úÖ
**File**: `packages/constants/index.ts`
- ‚úÖ Added utility functions for parsing file keys to extract components
- ‚úÖ Added functions to check if file key has downloadedAt timestamp
- ‚úÖ Added `getEpisodeFilePaths()` for generating all file paths
- ‚úÖ Added `isFileKeyNewer()` for comparing file keys by timestamp

**Phase 1 Results:**
- ‚úÖ New file format: `{YYYY-MM-DD}_{sanitized-title}--{unix-timestamp}`
- ‚úÖ Example: `2024-07-25_Simple_Episode_Title--1721921400000`
- ‚úÖ Strict sanitization: `"Caf√© & Na√Øve + More!"` ‚Üí `"Cafe_Naive_More"`
- ‚úÖ All packages build successfully with `pnpm all:build`
- ‚úÖ All existing tests continue to pass (validation package: 24 tests ‚úÖ)

**Phase 2.1 RSS Retrieval Results (2024-12-26):**
- ‚úÖ Updated imports to include new file key generation functions
- ‚úÖ Modified episode creation to capture `downloadedAt` timestamp at processing time
- ‚úÖ Switched to new file key format: `getEpisodeFileKeyWithDownloadedAt()`
- ‚úÖ Added `downloadedAt` field to episode manifest entries
- ‚úÖ Implemented cleanup logic to remove older versions of same episode
- ‚úÖ All tests continue passing (RSS retrieval: 28 tests ‚úÖ, validation: 24 tests ‚úÖ)
- ‚úÖ All packages build successfully with `pnpm all:build`

### Phase 2: Lambda Updates ‚úÖ **COMPLETED**

#### 2.1 RSS Retrieval Lambda Updates ‚úÖ
**File**: `packages/ingestion/rss-retrieval-lambda/retrieve-rss-feeds-and-download-audio-files.ts`
- ‚úÖ When downloading audio files, capture `downloadedAt` timestamp
- ‚úÖ Update episode manifest with `downloadedAt` field
- ‚úÖ Use new file key format for newly downloaded files
- ‚úÖ Add cleanup logic to remove older versions of same episode

#### 2.2 Process Audio Lambda Updates ‚úÖ **COMPLETED**
**File**: `packages/ingestion/process-audio-lambda/process-new-audio-files-via-whisper.ts`
- ‚úÖ Added imports for new file key generation functions  
- ‚úÖ Implemented logic to skip processing audio files with older downloadedAt when newer exists
- ‚úÖ Added cleanup logic to remove older transcript versions for same episode
- ‚úÖ Transcripts automatically match exact audio file using downloadedAt (existing logic works)

#### 2.3 SRT Indexing Lambda Updates ‚úÖ **COMPLETED**
**File**: `packages/ingestion/srt-indexing-lambda/convert-srts-indexed-search.ts`
- ‚úÖ Added imports for new file key generation functions
- ‚úÖ Implemented logic to skip processing transcript files with older downloadedAt when newer exists  
- ‚úÖ Added cleanup logic to remove older search entry versions for same episode
- ‚úÖ Search entries automatically match exact transcript file using downloadedAt (existing logic works)

### Phase 3: File Management Logic ‚úÖ **COMPLETED**

#### 3.1 File Cleanup Logic ‚úÖ **COMPLETED**
- ‚úÖ Enhanced lambdas to actually delete older versions (not just log)
- ‚úÖ Delete older audio/transcript/search-entry files when newer ones exist
- ‚úÖ Update manifest to remove entries for deleted files
- ‚úÖ RSS, Process Audio, and SRT Indexing lambdas now support real deletion

#### 3.2 File Consistency Checking ‚úÖ **COMPLETED**
- ‚úÖ Created comprehensive file consistency framework (`scripts/file-consistency-framework.md`)
- ‚úÖ Defined all consistency checks: missing files, orphaned files, version conflicts
- ‚úÖ Specified manifest validation requirements
- ‚úÖ Ready for implementation in validation package with existing S3 utilities
- ‚úÖ Safety-first approach: framework provided for user implementation

#### 3.3 File Consistency Implementation ‚úÖ **COMPLETED**
**File**: `packages/validation/check-file-consistency.ts`
- ‚úÖ Implemented comprehensive consistency checker using framework from 3.2
- ‚úÖ Uses existing `@browse-dot-show` package imports (S3, types, constants, logging)
- ‚úÖ Created command-line interface for running checks
- ‚úÖ Supports site-specific checking (e.g., `--site=naddpod`)
- ‚úÖ Generates detailed reports as outlined in framework
- ‚úÖ Ready to validate current state before Phase 4 migration
- ‚úÖ Added package dependencies and build scripts

### Phase 4: Migration & Backfill ‚è≥ **PENDING**

#### 4.1 Backfill Script for Existing Files
**New File**: `scripts/backfill-downloaded-at-timestamps.ts`
- ‚è≥ Scan existing audio files in S3 and local storage
- ‚è≥ Determine downloadedAt timestamp from file metadata (creation time)
- ‚è≥ Update episode manifest with inferred downloadedAt values
- ‚è≥ Rename files to new format if needed
- ‚è≥ Update corresponding transcript and search-entry files

#### 4.2 Migration Strategy
- **No Users Impact**: Sites don't have users yet, so temporary breakage during migration is acceptable
- **Backfill Process**: 
  1. Run against local files (assume current transcripts are accurate)
  2. Update transcripts to match downloadedAt for existing audio files
  3. Delete all S3 assets for the site to start fresh
  4. Use existing `pnpm s3:sync` script to sync fixed local files to S3
- **Post-Migration**: Only new format needs to be supported after backfill completion
- **Processing Flexibility**: Can be done locally or in Lambda - syncing always safe with downloadedAt tracking

#### 4.3 Phase 4 Implementation Context

**üîß Tools Available for Phase 4:**
- ‚úÖ **File Consistency Checker**: Validate before and after migration
- ‚úÖ **Enhanced Site Selection**: Use `--site=` for non-interactive scripts
- ‚úÖ **File Key Utilities**: Parse, generate, and validate file keys
- ‚úÖ **S3 Client**: Works with both local and AWS storage
- ‚úÖ **Cleanup Logic**: Delete older versions automatically

**üìã Phase 4 Prerequisites:**
1. **Pre-Migration Validation**: Run `pnpm validate:consistency --site=<target>` to check current state
2. **Backup Strategy**: Ensure local files are backed up before any modification
3. **Site Selection**: Use `--site=` parameter for automated scripts
4. **Test Site**: Consider testing on a smaller site first (e.g., `hardfork` with 143 episodes vs `claretandblue` with 928)

**üéØ Phase 4 Success Criteria:**
- All files follow new `{date}_{title}--{downloadedAt}` format
- Episode manifest has `downloadedAt` field for all episodes
- File consistency checker reports zero issues
- All three file types (audio, transcript, search-entry) match exactly
- No orphaned or missing files

**‚ö†Ô∏è Phase 4 Risks & Mitigations:**
- **Risk**: File corruption during rename operations
  - **Mitigation**: Work on copies, validate before overwriting
- **Risk**: Manifest inconsistencies  
  - **Mitigation**: Use consistency checker before and after each step
- **Risk**: S3 sync issues
  - **Mitigation**: Test sync process on single site first

**üîÑ Recommended Phase 4 Workflow:**
1. Choose test site with fewer episodes (e.g., `hardfork`)
2. Run pre-migration consistency check
3. Create local backup of all files
4. Implement backfill script with dry-run mode
5. Test on small subset of files
6. Run full backfill on test site
7. Validate results with consistency checker
8. Repeat for remaining sites

### Phase 5: Enhanced Logic ‚è≥ **PENDING**

#### 5.1 Smart Download Logic
**Enhancement to RSS Retrieval Lambda**:
- ‚è≥ Before downloading, check if audio already exists for this episode
- ‚è≥ Compare expected download size with existing file
- ‚è≥ Only download if significantly different (indicating ad changes)

#### 5.2 Dependency Checking
**Enhancement to all Lambdas**:
- ‚è≥ Before processing, verify all required input files exist
- ‚è≥ Check downloadedAt consistency across audio/transcript/search-entry
- ‚è≥ Log and handle mismatched files appropriately

## Detailed File Changes

### 1. Type Definition Updates

```typescript
// packages/types/episode-manifest.ts
export interface EpisodeInManifest {
    sequentialId: number;
    podcastId: PodcastId;
    title: string;
    fileKey: string; // Will now include downloadedAt timestamp
    originalAudioURL: string;
    summary: string;
    durationInSeconds?: number;
    publishedAt: string; // ISO 8601 date string
    downloadedAt?: string; // NEW: ISO 8601 timestamp when audio was downloaded
    hasCompletedLLMAnnotations: boolean;
    llmAnnotations: LlmAnnotations;
}
```

### 2. Enhanced File Key Generation

```typescript
// packages/ingestion/rss-retrieval-lambda/utils/get-episode-file-key.ts

function sanitizeTitleStrict(title: string): string {
    return title
        .normalize('NFC') // Normalize Unicode
        .replace(/[^a-zA-Z0-9]/g, '_') // Replace non-alphanumeric with underscore
        .replace(/_+/g, '_') // Replace multiple underscores with single
        .replace(/^_|_$/g, '') // Remove leading/trailing underscores
        .substring(0, 50); // Limit length
}

export function getEpisodeFileKeyWithDownloadedAt(
    episodeTitle: string, 
    pubDateStr: string, 
    downloadedAt: Date
): string {
    const date = parsePubDate(pubDateStr);
    const formattedDate = formatDateYYYYMMDD(date);
    const downloadedAtUnix = downloadedAt.getTime();
    const sanitizedTitle = sanitizeTitleStrict(episodeTitle);
    
    return `${formattedDate}_${sanitizedTitle}--${downloadedAtUnix}`;
}

// Backwards compatibility
export function getEpisodeFileKey(episodeTitle: string, pubDateStr: string): string {
    // Keep old behavior for migration compatibility
    const date = parsePubDate(pubDateStr);
    const formattedDate = formatDateYYYYMMDD(date);
    const sanitizedTitle = episodeTitle
        .normalize('NFC')
        .replace(/[/\\?%*:|"<>.]/g, '-')
        .replace(/\s+/g, '-')
        .substring(0, 50);
    return `${formattedDate}_${sanitizedTitle}`;
}

// Utility to check if file key has downloadedAt timestamp
export function hasDownloadedAtTimestamp(fileKey: string): boolean {
    return fileKey.includes('--') && /--\d{13}$/.test(fileKey);
}

// Extract downloadedAt from file key
export function extractDownloadedAtFromFileKey(fileKey: string): Date | null {
    const match = fileKey.match(/--(\d{13})$/);
    if (match) {
        return new Date(parseInt(match[1]));
    }
    return null;
}
```

### 3. RSS Retrieval Lambda Updates

```typescript
// packages/ingestion/rss-retrieval-lambda/retrieve-rss-feeds-and-download-audio-files.ts

// When creating new episode entries
const downloadedAt = new Date();
const newEpisodeToAdd: EpisodeInManifest = {
    sequentialId: 0,
    podcastId,
    title: episodeTitle,
    fileKey: getEpisodeFileKeyWithDownloadedAt(episodeTitle, pubDateString, downloadedAt),
    originalAudioURL,
    summary,
    durationInSeconds,
    publishedAt: parsedPublishedDate.toISOString(),
    downloadedAt: downloadedAt.toISOString(), // NEW FIELD
    hasCompletedLLMAnnotations: false,
    llmAnnotations: {},
};

// Add cleanup logic for older files
async function cleanupOlderVersions(episodeManifest: EpisodeManifest, podcastId: string): Promise<void> {
    // Group episodes by originalAudioURL to find duplicates
    const episodesByUrl = new Map<string, EpisodeInManifest[]>();
    
    episodeManifest.episodes
        .filter(ep => ep.podcastId === podcastId)
        .forEach(ep => {
            if (!episodesByUrl.has(ep.originalAudioURL)) {
                episodesByUrl.set(ep.originalAudioURL, []);
            }
            episodesByUrl.get(ep.originalAudioURL)!.push(ep);
        });
    
    // For each URL, keep only the newest downloadedAt version
    for (const [url, episodes] of episodesByUrl) {
        if (episodes.length > 1) {
            // Sort by downloadedAt, keep newest
            episodes.sort((a, b) => {
                const aTime = a.downloadedAt ? new Date(a.downloadedAt).getTime() : 0;
                const bTime = b.downloadedAt ? new Date(b.downloadedAt).getTime() : 0;
                return bTime - aTime; // Newest first
            });
            
            const [newest, ...older] = episodes;
            
            // Delete older files and remove from manifest
            for (const oldEpisode of older) {
                await deleteEpisodeFiles(oldEpisode, podcastId);
                const index = episodeManifest.episodes.indexOf(oldEpisode);
                if (index >= 0) {
                    episodeManifest.episodes.splice(index, 1);
                }
            }
        }
    }
}

async function deleteEpisodeFiles(episode: EpisodeInManifest, podcastId: string): Promise<void> {
    const audioPath = path.join(getAudioDirPrefix(), podcastId, `${episode.fileKey}.mp3`);
    const transcriptPath = path.join(getTranscriptsDirPrefix(), podcastId, `${episode.fileKey}.srt`);
    const searchEntryPath = path.join(getSearchEntriesDirPrefix(), podcastId, `${episode.fileKey}.json`);
    
    try {
        if (await fileExists(audioPath)) await deleteFile(audioPath);
        if (await fileExists(transcriptPath)) await deleteFile(transcriptPath);
        if (await fileExists(searchEntryPath)) await deleteFile(searchEntryPath);
        log.info(`Deleted older version files for: ${episode.fileKey}`);
    } catch (error) {
        log.error(`Error deleting files for ${episode.fileKey}:`, error);
    }
}
```

## Testing Strategy

### 1. Unit Tests
- Test new file key generation functions
- Test title sanitization with various inputs
- Test downloadedAt extraction from file keys

### 2. Integration Tests  
- Test full pipeline with new file format
- Test cleanup logic with multiple versions
- Test backfill script with sample data

### 3. Migration Testing
- Test backwards compatibility with existing files
- Test gradual migration of one site
- Validate file consistency after migration

## Risk Mitigation

### 1. Simplified Migration
- Support current format during backfill only
- Clean slate approach: delete S3 assets and sync from corrected local files
- No rollback needed due to no user impact

### 2. Data Integrity
- Comprehensive validation before and after migration
- Backup existing files before modification
- Detailed logging of all changes

### 3. Performance Impact
- Minimize disruption during migration
- Efficient cleanup algorithms
- Monitor Lambda execution times

## Questions & Considerations

1. **Phase 2 Completion Strategy**: Should we complete Phase 2.2 and 2.3 immediately, or test Phase 2.1 in isolation first?
2. **Migration Timeline**: Should we migrate all sites at once or one by one?
3. **Cleanup Strategy**: Should we immediately delete older files or keep them for a grace period?
4. **File Size Comparison**: How much size difference should trigger a re-download?
5. **Error Recovery**: How should we handle partial failures during cleanup?
6. **Monitoring**: What metrics should we track during and after migration?

**‚ö†Ô∏è URGENT PHASE 2 QUESTION**: 
Should we proceed immediately with Phase 2.2 (Process Audio Lambda) and 2.3 (SRT Indexing Lambda) to complete the downloadedAt implementation across all lambdas, or would you prefer to test the RSS Retrieval Lambda changes first?

A: Proceed to 2.2 & 2.3. Passing unit tests is sufficient for now.

## Success Criteria

- ‚úÖ **Phase 1**: All new downloads use downloadedAt timestamps (functions ready)
- ‚è≥ File consistency maintained across audio/transcript/search-entry
- ‚è≥ Successful cleanup of duplicate files
- ‚è≥ No broken links or missing files after migration
- ‚úÖ **Phase 1**: Improved title sanitization prevents encoding issues
- ‚è≥ Clear audit trail of when files were downloaded

## Current Status

**‚úÖ Phase 1 Complete (2024-12-26)**
- All core infrastructure ready
- File key generation and parsing functions implemented
- Comprehensive test coverage (28 tests passing)
- Cross-package compatibility verified

**‚úÖ Phase 2 Complete (2024-12-26)**
- All three lambdas updated to use new downloadedAt format
- RSS Retrieval Lambda: Captures downloadedAt timestamp when downloading audio
- Process Audio Lambda: Skips older audio versions, cleans up older transcripts  
- SRT Indexing Lambda: Skips older transcript versions, cleans up older search entries
- Comprehensive cleanup logic implemented across all lambdas
- All tests passing (56+ total tests across packages)
- All packages build successfully with `pnpm all:build`
- Production ready for new episode downloads

**‚úÖ Phase 3 Complete (2024-12-26)**
- ‚úÖ **3.1, 3.2 & 3.3 Complete**: File cleanup logic implemented, consistency framework created, and consistency checker implemented
- File cleanup logic fully implemented in all lambdas (actual deletion, not just logging)
- Comprehensive file consistency framework created (`scripts/file-consistency-framework.md`)
- File consistency checker implemented in `packages/validation/check-file-consistency.ts` (545 lines)
- Enhanced site selection system with `--site=` parameter support (non-interactive mode)
- Cleaned up legacy environment variables (`DEFAULT_SITE_ID`, `SKIP_SITE_SELECTION_PROMPT`)
- All infrastructure ready for Phase 4 migration
- Validated current state: All sites show 0 consistency issues

**‚ö†Ô∏è SAFETY NOTE FOR PHASE 3+:**
All file modification scripts should be reviewed and run manually by the user, not automatically executed. This ensures proper backups can be made before any file changes occur.

**Next Steps:**
- **Phase 4**: Create and run backfill scripts for existing files (convert legacy format to new downloadedAt format)
- Phase 5: Add enhanced logic and smart downloading

**‚úÖ INFRASTRUCTURE COMPLETE**: All core systems ready for Phase 4:
- File consistency checker with comprehensive validation
- Enhanced site selection with `--site=` parameter support  
- Cleanup logic for managing file versions
- Complete file key parsing and generation utilities
- Working S3 client for local and AWS operations

**üìã CURRENT STATE VALIDATION**: All sites show consistent file states:
```bash
# Tested sites - all showing 0 issues:
pnpm validate:consistency --site=naddpod     # ‚úÖ 397 episodes, 0 issues
pnpm validate:consistency --site=hardfork    # ‚úÖ 143 episodes, 0 issues  
pnpm validate:consistency --site=claretandblue # ‚úÖ 928 episodes, 0 issues
```

**üöÄ PHASE 4 READINESS CHECKLIST:**
- ‚úÖ **File format functions**: Parse, generate, validate file keys
- ‚úÖ **Cleanup logic**: Automatically remove older versions  
- ‚úÖ **Validation tools**: Comprehensive consistency checking
- ‚úÖ **Site management**: Enhanced selection with `--site=` parameter
- ‚úÖ **Current state**: All files validated as consistent
- ‚úÖ **Environment clean**: Legacy variables removed
- ‚è≥ **Backfill script**: Implementation needed for Phase 4

**üìù NOTES FOR PHASE 4 IMPLEMENTATION:**
- All existing files currently use legacy format (no downloadedAt timestamps)
- Manifest entries missing `downloadedAt` field  
- Need to infer timestamps from file metadata or use current time
- Recommend starting with smaller site (`hardfork`: 143 episodes) for testing
- Use dry-run mode for initial testing to avoid data loss

## Key Files & Directories Reference

### Core Types & Configuration
- `packages/types/episode-manifest.ts` - Episode data structure definitions
- `packages/config/` - RSS feed configurations and search facets
- `sites/origin-sites/` - Site-specific configurations and assets

### Ingestion Pipeline (Lambdas)
- `packages/ingestion/rss-retrieval-lambda/` - Downloads audio from RSS feeds
- `packages/ingestion/process-audio-lambda/` - Transcribes audio using Whisper
- `packages/ingestion/srt-indexing-lambda/` - Converts transcripts to search entries

### File Key & Validation Utils
- `packages/ingestion/rss-retrieval-lambda/utils/get-episode-file-key.ts` - File naming logic
- `packages/validation/utils/get-episode-file-key.ts` - Validation utilities
- `packages/validation/check-file-consistency.ts` - **NEW**: File consistency checker (545 lines)
- `packages/validation/FILE_CONSISTENCY_CHECKER.md` - **NEW**: Documentation and usage guide
- `packages/constants/index.ts` - Shared file key parsing functions

### Data Storage Structure
- `audio/{podcastId}/{fileKey}.mp3` - Audio files
- `transcripts/{podcastId}/{fileKey}.srt` - Transcript files  
- `search-entries/{podcastId}/{fileKey}.json` - Search index data
- `episode-manifest/full-episode-manifest.json` - Central episode tracking

### Build & Deployment
- `scripts/` - Deployment and site management scripts
- `scripts/run-with-site-selection.ts` - **ENHANCED**: Now supports `--site=` parameter
- `scripts/SITE_SELECTION_ENHANCEMENT.md` - **NEW**: Documentation of site selection improvements
- `terraform/` - AWS infrastructure definitions
- `packages/client/` - Frontend applications
- `packages/homepage/` - Homepage application